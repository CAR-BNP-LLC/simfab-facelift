/**
 * Order Service
 * Handles order creation and management
 */

import { Pool } from 'pg';
import {
  Order,
  OrderWithItems,
  OrderItem,
  OrderStatus,
  PaymentStatus,
  CreateOrderData,
  Address
} from '../types/cart';
import { CartService } from './CartService';
import { StockReservationService } from './StockReservationService';
import { NotFoundError, ValidationError } from '../utils/errors';

export class OrderService {
  private cartService: CartService;
  private stockReservationService: StockReservationService;

  constructor(private pool: Pool) {
    this.cartService = new CartService(pool);
    this.stockReservationService = new StockReservationService(pool);
  }

  /**
   * Create order from cart
   */
  async createOrder(
    sessionId: string | undefined,
    userId: number | undefined,
    orderData: CreateOrderData
  ): Promise<OrderWithItems> {
    const client = await this.pool.connect();

    try {
      await client.query('BEGIN');

      // Get cart with items
      const cart = await this.cartService.getCartWithItems(sessionId, userId);

      if (!cart || cart.items.length === 0) {
        throw new ValidationError('Cannot create order with empty cart');
      }
      
      if (!cart.region) {
        throw new ValidationError('Cart region is missing');
      }
      
      console.log('Cart items for order creation:', cart.items.map(item => ({
        product_id: item.product_id,
        product_name: item.product_name,
        product_image: item.product_image
      })));

      // Validate cart
      const validation = await this.cartService.validateCartForCheckout(cart.id);
      if (!validation.valid) {
        throw new ValidationError('Cart validation failed', { errors: validation.errors });
      }

      // Calculate totals - use provided shipping/tax if available, otherwise use cart totals
      const subtotal = cart.totals.subtotal;
      const discount = cart.totals.discount;
      const shipping = orderData.shippingAmount !== undefined ? orderData.shippingAmount : cart.totals.shipping;
      const tax = orderData.taxAmount !== undefined ? orderData.taxAmount : cart.totals.tax;
      const total = subtotal - discount + shipping + tax;
      const currency = cart.totals.currency || (cart.region === 'eu' ? 'EUR' : 'USD');

      console.log('ðŸ’° Order totals calculation:', {
        subtotal,
        discount,
        shipping,
        tax,
        total,
        currency,
        formula: `${subtotal} - ${discount} + ${shipping} + ${tax} = ${total}`,
        'orderData.shippingAmount': orderData.shippingAmount,
        'orderData.taxAmount': orderData.taxAmount,
        'cart.totals.shipping': cart.totals.shipping,
        'cart.totals.tax': cart.totals.tax
      });

      // Determine if international shipping
      const isInternational = orderData.shippingAddress.country && 
        !['US', 'CA'].includes(orderData.shippingAddress.country);
      
      // Get package size (default to M if not provided)
      const packageSize = orderData.packageSize || 'M';

      // Create order with payment expiration (order_number will be auto-generated by database trigger)
      const orderSql = `
        INSERT INTO orders (
          user_id, cart_id, status, payment_status, shipping_status,
          subtotal, tax_amount, shipping_amount, discount_amount, total_amount, currency, region,
          customer_email, customer_phone,
          billing_address, shipping_address,
          payment_method, shipping_method, notes,
          payment_expires_at, stock_reserved,
          package_size, is_international_shipping
        ) VALUES (
          $1, $2, $3, $4, $5,
          $6, $7, $8, $9, $10, $11, $12,
          $13, $14,
          $15, $16,
          $17, $18, $19,
          $20, $21,
          $22, $23
        )
        RETURNING *
      `;

      const paymentExpiresAt = new Date(Date.now() + 15 * 60 * 1000); // 15 minutes

      const orderResult = await client.query(orderSql, [
        userId || null,           // $1 user_id
        cart.id,                   // $2 cart_id
        OrderStatus.PENDING,       // $3 status
        PaymentStatus.PENDING,      // $4 payment_status
        'pending',                  // $5 shipping_status
        subtotal,                   // $6 subtotal
        tax,                        // $7 tax_amount
        shipping,                   // $8 shipping_amount
        discount,                    // $9 discount_amount
        total,                      // $10 total_amount
        currency,                   // $11 currency
        cart.region,                // $12 region
        orderData.billingAddress.email || orderData.shippingAddress.email || '',  // $13 customer_email
        orderData.billingAddress.phone || orderData.shippingAddress.phone || null, // $14 customer_phone
        JSON.stringify(orderData.billingAddress),   // $15 billing_address
        JSON.stringify(orderData.shippingAddress), // $16 shipping_address
        orderData.paymentMethodId || null,         // $17 payment_method
        orderData.shippingMethodId || null,        // $18 shipping_method
        orderData.orderNotes || null,              // $19 notes
        paymentExpiresAt,                          // $20 payment_expires_at
        true,                                      // $21 stock_reserved
        packageSize,                                // $22 package_size
        isInternational                             // $23 is_international_shipping
      ]);

      const order = orderResult.rows[0];

      // Create order items from cart items
      const orderItems: OrderItem[] = [];

      for (const cartItem of cart.items) {
        console.log('Creating order item from cart item:', {
          product_id: cartItem.product_id,
          product_name: cartItem.product_name,
          product_sku: cartItem.product_sku,
          product_image: cartItem.product_image,
          has_image: !!cartItem.product_image
        });
        
        const orderItemSql = `
          INSERT INTO order_items (
            order_id, product_id, product_name, product_sku, product_image,
            quantity, unit_price, total_price, selected_options
          ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
          RETURNING *
        `;

        const orderItemResult = await client.query(orderItemSql, [
          order.id,
          cartItem.product_id,
          cartItem.product_name,
          cartItem.product_sku,
          cartItem.product_image || null,
          cartItem.quantity,
          cartItem.unit_price,
          cartItem.total_price,
          cartItem.configuration
        ]);
        
        console.log('Order item created with image:', {
          id: orderItemResult.rows[0].id,
          product_image: orderItemResult.rows[0].product_image
        });

        orderItems.push(orderItemResult.rows[0]);

        // Reserve stock (handles both product-level and variation-level stock)
        await this.stockReservationService.reserveStock(
          order.id,
          cartItem.product_id,
          cartItem.quantity,
          client
        );

        // Reserve variation stock if configuration has variation selections
        if (cartItem.configuration?.variations) {
          await this.stockReservationService.reserveVariationStock(
            order.id,
            cartItem.configuration,
            cartItem.quantity
          );
        }
      }

      // Preserve cart for checkout - don't clear until payment is completed
      await client.query('UPDATE carts SET status = $1 WHERE id = $2', ['checkout', cart.id]);

      await client.query('COMMIT');

      return {
        ...order,
        items: orderItems
      };
    } catch (error) {
      await client.query('ROLLBACK');
      if (error instanceof ValidationError || error instanceof NotFoundError) {
        throw error;
      }
      console.error('Error creating order:', error);
      throw error;
    } finally {
      client.release();
    }
  }

  /**
   * Get user's orders
   */
  async getUserOrders(userId: number, page: number = 1, limit: number = 10): Promise<{
    orders: Order[];
    total: number;
    page: number;
    totalPages: number;
  }> {
    try {
      const offset = (page - 1) * limit;

      const ordersSql = `
        SELECT * FROM orders
        WHERE user_id = $1
        ORDER BY created_at DESC
        LIMIT $2 OFFSET $3
      `;

      const countSql = `
        SELECT COUNT(*)::int as total FROM orders WHERE user_id = $1
      `;

      const [ordersResult, countResult] = await Promise.all([
        this.pool.query(ordersSql, [userId, limit, offset]),
        this.pool.query(countSql, [userId])
      ]);

      const total = countResult.rows[0].total;
      const totalPages = Math.ceil(total / limit);

      return {
        orders: ordersResult.rows,
        total,
        page,
        totalPages
      };
    } catch (error) {
      console.error('Error getting user orders:', error);
      throw error;
    }
  }

  /**
   * Update order status
   */
  async updateOrderStatus(orderId: number, status: OrderStatus): Promise<Order> {
    const sql = `
      UPDATE orders
      SET status = $1, updated_at = CURRENT_TIMESTAMP
      WHERE id = $2
      RETURNING *
    `;

    const result = await this.pool.query(sql, [status, orderId]);

    if (result.rows.length === 0) {
      throw new NotFoundError('Order', { orderId });
    }

    return result.rows[0];
  }

  /**
   * Cancel order
   */
  async cancelOrder(orderNumber: string, userId?: number): Promise<Order> {
    const client = await this.pool.connect();

    try {
      await client.query('BEGIN');

      // Get order
      let sql = 'SELECT * FROM orders WHERE order_number = $1';
      const params: any[] = [orderNumber];

      if (userId) {
        sql += ' AND user_id = $2';
        params.push(userId);
      }

      const orderResult = await client.query(sql, params);

      if (orderResult.rows.length === 0) {
        throw new NotFoundError('Order', { orderNumber });
      }

      const order = orderResult.rows[0];

      // Can only cancel pending or processing orders
      if (!['pending', 'processing'].includes(order.status)) {
        throw new ValidationError('Order cannot be cancelled at this stage', {
          currentStatus: order.status
        });
      }

      // Cancel stock reservations instead of restoring stock
      await this.stockReservationService.cancelReservation(order.id, client);

      // Update order status
      const updateSql = `
        UPDATE orders
        SET status = $1, updated_at = CURRENT_TIMESTAMP
        WHERE id = $2
        RETURNING *
      `;

      const result = await client.query(updateSql, [OrderStatus.CANCELLED, order.id]);

      await client.query('COMMIT');

      return result.rows[0];
    } catch (error) {
      await client.query('ROLLBACK');
      if (error instanceof NotFoundError || error instanceof ValidationError) {
        throw error;
      }
      console.error('Error cancelling order:', error);
      throw error;
    } finally {
      client.release();
    }
  }

  /**
   * Confirm stock reservations for paid order
   */
  async confirmOrderPayment(orderId: number): Promise<void> {
    const client = await this.pool.connect();
    
    try {
      await client.query('BEGIN');

      // Confirm stock reservations (both product-level and variation-level)
      await this.stockReservationService.confirmReservation(orderId, client);
      
      // Confirm variation stock reservations
      await this.stockReservationService.confirmVariationReservations(orderId);

      // Update order status
      await client.query(
        `UPDATE orders 
         SET payment_status = $1, status = $2, updated_at = CURRENT_TIMESTAMP
         WHERE id = $3`,
        [PaymentStatus.PAID, OrderStatus.PROCESSING, orderId]
      );

      // Record coupon usage
      const orderResult = await client.query(
        'SELECT cart_id, user_id, discount_amount FROM orders WHERE id = $1',
        [orderId]
      );

      if (orderResult.rows.length > 0) {
        const order = orderResult.rows[0];
        const cartId = order.cart_id;
        const userId = order.user_id;

        // Get applied coupons for this cart
        const cartCouponsResult = await client.query(
          'SELECT coupon_id, discount_amount FROM cart_coupons WHERE cart_id = $1',
          [cartId]
        );

        // Record each coupon usage
        for (const cartCoupon of cartCouponsResult.rows) {
          await client.query(
            `INSERT INTO coupon_usage (coupon_id, user_id, order_id, discount_amount)
             VALUES ($1, $2, $3, $4)`,
            [cartCoupon.coupon_id, userId, orderId, cartCoupon.discount_amount]
          );
        }
      }

      await client.query('COMMIT');
    } catch (error) {
      await client.query('ROLLBACK');
      console.error('Error confirming order payment:', error);
      throw error;
    } finally {
      client.release();
    }
  }

  /**
   * Clean up expired orders and their reservations
   * This will DELETE the orders completely so they don't appear in admin dashboard
   */
  async cleanupExpiredOrders(): Promise<number> {
    const client = await this.pool.connect();
    
    try {
      await client.query('BEGIN');

      // Get expired orders
      const expiredOrders = await client.query(
        `SELECT id FROM orders 
         WHERE payment_status = 'pending' 
         AND payment_expires_at < NOW() 
         AND status = 'pending'`
      );

      let cleanedCount = 0;

      for (const order of expiredOrders.rows) {
        // Cancel stock reservations first
        await this.stockReservationService.cancelReservation(order.id, client);

        // Delete the order completely (this will cascade delete order_items due to foreign key)
        await client.query(
          `DELETE FROM orders WHERE id = $1`,
          [order.id]
        );

        cleanedCount++;
      }

      await client.query('COMMIT');
      console.log(`Cleaned up ${cleanedCount} expired unpaid orders`);
      return cleanedCount;
    } catch (error) {
      await client.query('ROLLBACK');
      console.error('Error cleaning up expired orders:', error);
      throw error;
    } finally {
      client.release();
    }
  }


  /**
   * Get order by ID
   */
  async getOrderById(orderId: number): Promise<Order | null> {
    const client = await this.pool.connect();
    
    try {
      const result = await client.query(
        `SELECT o.*, 
                json_agg(
                  json_build_object(
                    'id', oi.id,
                    'product_id', oi.product_id,
                    'product_name', oi.product_name,
                    'product_sku', oi.product_sku,
                    'quantity', oi.quantity,
                    'unit_price', oi.unit_price,
                    'total_price', oi.total_price,
                    'selected_options', oi.selected_options
                  )
                ) as items
         FROM orders o
         LEFT JOIN order_items oi ON o.id = oi.order_id
         WHERE o.id = $1
         GROUP BY o.id`,
        [orderId]
      );

      if (result.rows.length === 0) {
        return null;
      }

      const order = result.rows[0];
      return {
        ...order,
        items: order.items.filter((item: any) => item.id !== null) // Remove null items
      };
    } catch (error) {
      console.error('Error getting order by ID:', error);
      throw error;
    } finally {
      client.release();
    }
  }

  /**
   * Get order by order number
   */
  async getOrderByNumber(orderNumber: string): Promise<Order | null> {
    const client = await this.pool.connect();
    
    try {
      const result = await client.query(
        `SELECT o.*, 
                json_agg(
                  json_build_object(
                    'id', oi.id,
                    'product_id', oi.product_id,
                    'product_name', oi.product_name,
                    'product_sku', oi.product_sku,
                    'quantity', oi.quantity,
                    'unit_price', oi.unit_price,
                    'total_price', oi.total_price,
                    'selected_options', oi.selected_options
                  )
                ) as items
         FROM orders o
         LEFT JOIN order_items oi ON o.id = oi.order_id
         WHERE o.order_number = $1
         GROUP BY o.id`,
        [orderNumber]
      );

      if (result.rows.length === 0) {
        return null;
      }

      const order = result.rows[0];
      return {
        ...order,
        items: order.items.filter((item: any) => item.id !== null) // Remove null items
      };
    } catch (error) {
      console.error('Error getting order by number:', error);
      throw error;
    } finally {
      client.release();
    }
  }
}

