/**
 * Order Service
 * Handles order creation and management
 */

import { Pool } from 'pg';
import {
  Order,
  OrderWithItems,
  OrderItem,
  OrderStatus,
  PaymentStatus,
  CreateOrderData,
  Address
} from '../types/cart';
import { CartService } from './CartService';
import { StockReservationService } from './StockReservationService';
import { NotFoundError, ValidationError } from '../utils/errors';

export class OrderService {
  private cartService: CartService;
  private stockReservationService: StockReservationService;

  constructor(private pool: Pool) {
    this.cartService = new CartService(pool);
    this.stockReservationService = new StockReservationService(pool);
  }

  /**
   * Create order from cart
   */
  async createOrder(
    sessionId: string | undefined,
    userId: number | undefined,
    orderData: CreateOrderData
  ): Promise<OrderWithItems> {
    const client = await this.pool.connect();

    try {
      await client.query('BEGIN');

      // Get cart with items
      const cart = await this.cartService.getCartWithItems(sessionId, userId);

      if (!cart || cart.items.length === 0) {
        throw new ValidationError('Cannot create order with empty cart');
      }
      
      console.log('Cart items for order creation:', cart.items.map(item => ({
        product_id: item.product_id,
        product_name: item.product_name,
        product_image: item.product_image
      })));

      // Validate cart
      const validation = await this.cartService.validateCartForCheckout(cart.id);
      if (!validation.valid) {
        throw new ValidationError('Cart validation failed', { errors: validation.errors });
      }

      // Calculate totals
      const subtotal = cart.totals.subtotal;
      const discount = cart.totals.discount;
      const shipping = cart.totals.shipping;
      const tax = cart.totals.tax;
      const total = cart.totals.total;

      // Create order with payment expiration (order_number will be auto-generated by database trigger)
      const orderSql = `
        INSERT INTO orders (
          user_id, cart_id, status, payment_status, shipping_status,
          subtotal, tax_amount, shipping_amount, discount_amount, total_amount, currency,
          customer_email, customer_phone,
          billing_address, shipping_address,
          payment_method, shipping_method, notes,
          payment_expires_at, stock_reserved
        ) VALUES (
          $1, $2, $3, $4, $5,
          $6, $7, $8, $9, $10, $11,
          $12, $13,
          $14, $15,
          $16, $17, $18,
          $19, $20
        )
        RETURNING *
      `;

      const paymentExpiresAt = new Date(Date.now() + 15 * 60 * 1000); // 15 minutes

      const orderResult = await client.query(orderSql, [
        userId || null,
        cart.id,
        OrderStatus.PENDING,
        PaymentStatus.PENDING,
        'pending',
        subtotal,
        tax,
        shipping,
        discount,
        total,
        'USD',
        orderData.billingAddress.email || orderData.shippingAddress.email || '',
        orderData.billingAddress.phone || orderData.shippingAddress.phone || null,
        JSON.stringify(orderData.billingAddress),
        JSON.stringify(orderData.shippingAddress),
        orderData.paymentMethodId || null,
        orderData.shippingMethodId || null,
        orderData.orderNotes || null,
        paymentExpiresAt,
        true
      ]);

      const order = orderResult.rows[0];

      // Create order items from cart items
      const orderItems: OrderItem[] = [];

      for (const cartItem of cart.items) {
        console.log('Creating order item from cart item:', {
          product_id: cartItem.product_id,
          product_name: cartItem.product_name,
          product_sku: cartItem.product_sku,
          product_image: cartItem.product_image,
          has_image: !!cartItem.product_image
        });
        
        const orderItemSql = `
          INSERT INTO order_items (
            order_id, product_id, product_name, product_sku, product_image,
            quantity, unit_price, total_price, selected_options
          ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
          RETURNING *
        `;

        const orderItemResult = await client.query(orderItemSql, [
          order.id,
          cartItem.product_id,
          cartItem.product_name,
          cartItem.product_sku,
          cartItem.product_image || null,
          cartItem.quantity,
          cartItem.unit_price,
          cartItem.total_price,
          cartItem.configuration
        ]);
        
        console.log('Order item created with image:', {
          id: orderItemResult.rows[0].id,
          product_image: orderItemResult.rows[0].product_image
        });

        orderItems.push(orderItemResult.rows[0]);

        // Reserve stock instead of immediately deducting
        await this.stockReservationService.reserveStock(
          order.id,
          cartItem.product_id,
          cartItem.quantity,
          client
        );
      }

      // Preserve cart for checkout - don't clear until payment is completed
      await client.query('UPDATE carts SET status = $1 WHERE id = $2', ['checkout', cart.id]);

      await client.query('COMMIT');

      return {
        ...order,
        items: orderItems
      };
    } catch (error) {
      await client.query('ROLLBACK');
      if (error instanceof ValidationError || error instanceof NotFoundError) {
        throw error;
      }
      console.error('Error creating order:', error);
      throw error;
    } finally {
      client.release();
    }
  }

  /**
   * Get user's orders
   */
  async getUserOrders(userId: number, page: number = 1, limit: number = 10): Promise<{
    orders: Order[];
    total: number;
    page: number;
    totalPages: number;
  }> {
    try {
      const offset = (page - 1) * limit;

      const ordersSql = `
        SELECT * FROM orders
        WHERE user_id = $1
        ORDER BY created_at DESC
        LIMIT $2 OFFSET $3
      `;

      const countSql = `
        SELECT COUNT(*)::int as total FROM orders WHERE user_id = $1
      `;

      const [ordersResult, countResult] = await Promise.all([
        this.pool.query(ordersSql, [userId, limit, offset]),
        this.pool.query(countSql, [userId])
      ]);

      const total = countResult.rows[0].total;
      const totalPages = Math.ceil(total / limit);

      return {
        orders: ordersResult.rows,
        total,
        page,
        totalPages
      };
    } catch (error) {
      console.error('Error getting user orders:', error);
      throw error;
    }
  }

  /**
   * Update order status
   */
  async updateOrderStatus(orderId: number, status: OrderStatus): Promise<Order> {
    const sql = `
      UPDATE orders
      SET status = $1, updated_at = CURRENT_TIMESTAMP
      WHERE id = $2
      RETURNING *
    `;

    const result = await this.pool.query(sql, [status, orderId]);

    if (result.rows.length === 0) {
      throw new NotFoundError('Order', { orderId });
    }

    return result.rows[0];
  }

  /**
   * Cancel order
   */
  async cancelOrder(orderNumber: string, userId?: number): Promise<Order> {
    const client = await this.pool.connect();

    try {
      await client.query('BEGIN');

      // Get order
      let sql = 'SELECT * FROM orders WHERE order_number = $1';
      const params: any[] = [orderNumber];

      if (userId) {
        sql += ' AND user_id = $2';
        params.push(userId);
      }

      const orderResult = await client.query(sql, params);

      if (orderResult.rows.length === 0) {
        throw new NotFoundError('Order', { orderNumber });
      }

      const order = orderResult.rows[0];

      // Can only cancel pending or processing orders
      if (!['pending', 'processing'].includes(order.status)) {
        throw new ValidationError('Order cannot be cancelled at this stage', {
          currentStatus: order.status
        });
      }

      // Cancel stock reservations instead of restoring stock
      await this.stockReservationService.cancelReservation(order.id, client);

      // Update order status
      const updateSql = `
        UPDATE orders
        SET status = $1, updated_at = CURRENT_TIMESTAMP
        WHERE id = $2
        RETURNING *
      `;

      const result = await client.query(updateSql, [OrderStatus.CANCELLED, order.id]);

      await client.query('COMMIT');

      return result.rows[0];
    } catch (error) {
      await client.query('ROLLBACK');
      if (error instanceof NotFoundError || error instanceof ValidationError) {
        throw error;
      }
      console.error('Error cancelling order:', error);
      throw error;
    } finally {
      client.release();
    }
  }

  /**
   * Confirm stock reservations for paid order
   */
  async confirmOrderPayment(orderId: number): Promise<void> {
    const client = await this.pool.connect();
    
    try {
      await client.query('BEGIN');

      // Confirm stock reservations
      await this.stockReservationService.confirmReservation(orderId, client);

      // Update order status
      await client.query(
        `UPDATE orders 
         SET payment_status = $1, status = $2, updated_at = CURRENT_TIMESTAMP
         WHERE id = $3`,
        [PaymentStatus.PAID, OrderStatus.PROCESSING, orderId]
      );

      await client.query('COMMIT');
    } catch (error) {
      await client.query('ROLLBACK');
      console.error('Error confirming order payment:', error);
      throw error;
    } finally {
      client.release();
    }
  }

  /**
   * Clean up expired orders and their reservations
   * This will DELETE the orders completely so they don't appear in admin dashboard
   */
  async cleanupExpiredOrders(): Promise<number> {
    const client = await this.pool.connect();
    
    try {
      await client.query('BEGIN');

      // Get expired orders
      const expiredOrders = await client.query(
        `SELECT id FROM orders 
         WHERE payment_status = 'pending' 
         AND payment_expires_at < NOW() 
         AND status = 'pending'`
      );

      let cleanedCount = 0;

      for (const order of expiredOrders.rows) {
        // Cancel stock reservations first
        await this.stockReservationService.cancelReservation(order.id, client);

        // Delete the order completely (this will cascade delete order_items due to foreign key)
        await client.query(
          `DELETE FROM orders WHERE id = $1`,
          [order.id]
        );

        cleanedCount++;
      }

      await client.query('COMMIT');
      console.log(`Cleaned up ${cleanedCount} expired unpaid orders`);
      return cleanedCount;
    } catch (error) {
      await client.query('ROLLBACK');
      console.error('Error cleaning up expired orders:', error);
      throw error;
    } finally {
      client.release();
    }
  }


  /**
   * Get order by ID
   */
  async getOrderById(orderId: number): Promise<Order | null> {
    const client = await this.pool.connect();
    
    try {
      const result = await client.query(
        `SELECT o.*, 
                json_agg(
                  json_build_object(
                    'id', oi.id,
                    'product_id', oi.product_id,
                    'product_name', oi.product_name,
                    'product_sku', oi.product_sku,
                    'quantity', oi.quantity,
                    'unit_price', oi.unit_price,
                    'total_price', oi.total_price,
                    'selected_options', oi.selected_options
                  )
                ) as items
         FROM orders o
         LEFT JOIN order_items oi ON o.id = oi.order_id
         WHERE o.id = $1
         GROUP BY o.id`,
        [orderId]
      );

      if (result.rows.length === 0) {
        return null;
      }

      const order = result.rows[0];
      return {
        ...order,
        items: order.items.filter((item: any) => item.id !== null) // Remove null items
      };
    } catch (error) {
      console.error('Error getting order by ID:', error);
      throw error;
    } finally {
      client.release();
    }
  }

  /**
   * Get order by order number
   */
  async getOrderByNumber(orderNumber: string): Promise<Order | null> {
    const client = await this.pool.connect();
    
    try {
      const result = await client.query(
        `SELECT o.*, 
                json_agg(
                  json_build_object(
                    'id', oi.id,
                    'product_id', oi.product_id,
                    'product_name', oi.product_name,
                    'product_sku', oi.product_sku,
                    'quantity', oi.quantity,
                    'unit_price', oi.unit_price,
                    'total_price', oi.total_price,
                    'selected_options', oi.selected_options
                  )
                ) as items
         FROM orders o
         LEFT JOIN order_items oi ON o.id = oi.order_id
         WHERE o.order_number = $1
         GROUP BY o.id`,
        [orderNumber]
      );

      if (result.rows.length === 0) {
        return null;
      }

      const order = result.rows[0];
      return {
        ...order,
        items: order.items.filter((item: any) => item.id !== null) // Remove null items
      };
    } catch (error) {
      console.error('Error getting order by number:', error);
      throw error;
    } finally {
      client.release();
    }
  }
}

